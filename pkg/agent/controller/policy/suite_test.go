/*
Copyright 2021 The Everoute Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package policy

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/agiledragon/gomonkey/v2"
	. "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"
	"github.com/onsi/gomega/format"
	gtypes "github.com/onsi/gomega/types"
	"k8s.io/client-go/kubernetes/scheme"
	"k8s.io/klog/v2"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/envtest"

	"github.com/everoute/everoute/pkg/agent/controller/policy/cache"
	"github.com/everoute/everoute/pkg/agent/datapath"
	clientsetscheme "github.com/everoute/everoute/pkg/client/clientset_generated/clientset/scheme"
	msconst "github.com/everoute/everoute/pkg/constants/ms"
	"github.com/everoute/everoute/pkg/metrics"
	"github.com/everoute/everoute/pkg/types"
	"github.com/everoute/everoute/plugin/tower/pkg/informer"
)

// These tests use Ginkgo (BDD-style Go testing framework). Refer to
// http://onsi.github.io/ginkgo/ to learn more about Ginkgo.

var (
	k8sClient             client.Client // You'll be using this client in your tests.
	testEnv               *envtest.Environment
	ruleCacheLister       informer.Lister
	globalRuleCacheLister informer.Lister
	useExistingCluster    bool
	ctx, cancel           = context.WithCancel(ctrl.SetupSignalHandler())
	pCtrl                 *Reconciler
	mocks                 = gomonkey.NewPatches()
)

const (
	RunTestWithExistingCluster = "TESTING_WITH_EXISTING_CLUSTER"
	brName                     = "bridgeUT"
)

func TestPolicyController(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "PolicyController Suite")
}

var _ = BeforeSuite(func() {
	//var l klog.Level = 4
	//l.Set("4")

	ctrl.SetLogger(klog.Background())
	if os.Getenv(RunTestWithExistingCluster) == "true" {
		By("testing with existing cluster")
		useExistingCluster = true
	}
	// Wait for policyrule test initialize DpManager, and then start flow relay test, avoid connection reset error
	time.Sleep(time.Second * 10)
	/*
		First, the envtest cluster is configured to read CRDs from the CRD directory Kubebuilder scaffolds for you.
	*/
	By("bootstrapping test environment")
	testEnv = &envtest.Environment{
		UseExistingCluster: &useExistingCluster,
		CRDInstallOptions: envtest.CRDInstallOptions{
			Paths:           []string{filepath.Join("..", "..", "..", "..", "deploy", "chart", "templates", "crds")},
			CleanUpAfterUse: true,
		},
	}

	/*
		Then, we start the envtest cluster.
	*/
	cfg, err := testEnv.Start()
	Expect(err).NotTo(HaveOccurred())
	Expect(cfg).NotTo(BeNil())

	/*
		The autogenerated test code will add schema to the default client-go k8s scheme.
	*/
	err = clientsetscheme.AddToScheme(scheme.Scheme)
	Expect(err).Should(Succeed())

	/*
		One thing that this autogenerated file is missing, however, is a way to actually start your controller.
		The code above will set up a client for interacting with your custom Kind,
		but will not be able to test your controller behavior.
		If you want to test your custom controller logic, you’ll need to add some familiar-looking manager logic
		to your BeforeSuite() function, so you can register your custom controller to run on this test cluster.
		You may notice that the code below runs your controller with nearly identical logic to your CronJob project’s main.go!
		The only difference is that the manager is started in a separate goroutine so it does not block the cleanup of envtest
		when you’re done running your tests.
		Once you've added the code below, you can actually delete the k8sClient above, because you can get k8sClient from the manager
		(as shown below).
	*/

	k8sManager, err := ctrl.NewManager(cfg, ctrl.Options{
		Scheme: scheme.Scheme,
		// disable metrics serving
		MetricsBindAddress: "0",
	})
	Expect(err).ToNot(HaveOccurred())
	Expect(k8sManager).ToNot(BeNil())

	Expect(datapath.ExcuteCommand(datapath.SetupBridgeChain, brName)).ToNot(HaveOccurred())

	updateChan := make(chan *types.EndpointIP, 10)
	datapathManager := datapath.NewDatapathManager(&datapath.DpManagerConfig{
		ManagedVDSMap: map[string]string{
			brName: brName,
		}}, updateChan, metrics.NewAgentMetric())
	datapathManager.InitializeDatapath(ctx)

	pCtrl = &Reconciler{
		Client:          k8sManager.GetClient(),
		Scheme:          k8sManager.GetScheme(),
		DatapathManager: datapathManager,
	}
	err = (pCtrl).SetupWithManager(k8sManager)
	Expect(err).ToNot(HaveOccurred())
	cutT := time.Now()
	pCtrl.globalRuleFirstProcessedTime = &cutT
	pCtrl.sysProcessedPolicy.Insert(msconst.ERvmPolicy)
	pCtrl.sysProcessedPolicy.Insert(msconst.SysEPPolicy)
	pCtrl.sysProcessedPolicy.Insert(msconst.LBPolicy)

	ruleCacheLister = pCtrl.GetCompleteRuleLister()
	Expect(ruleCacheLister).ShouldNot(BeNil())

	globalRuleCacheLister = pCtrl.GetGlobalRuleLister()
	Expect(globalRuleCacheLister).ShouldNot(BeNil())

	mocks.ApplyMethodFunc(datapathManager, "AddEveroutePolicyRule", func(_ context.Context, _ *datapath.EveroutePolicyRule, _ datapath.RuleBaseInfo) error {
		return nil
	})
	mocks.ApplyMethodFunc(datapathManager, "RemoveEveroutePolicyRule", func(_ context.Context, _ string, _ datapath.RuleBaseInfo) error {
		return nil
	})

	go func() {
		err = k8sManager.Start(ctx)
		Expect(err).ToNot(HaveOccurred())
	}()

	k8sClient = k8sManager.GetClient()
	Expect(k8sClient).ToNot(BeNil())
	Expect(k8sManager.GetCache().WaitForCacheSync(ctx)).Should(BeTrue())
}, 60)

var _ = AfterSuite(func() {
	By("stop controller manager")
	mocks.Reset()
	cancel()
	By("tearing down the test environment")
	err := testEnv.Stop()
	Expect(err).NotTo(HaveOccurred())
	Expect(datapath.ExcuteCommand(datapath.CleanBridgeChain, brName)).NotTo(HaveOccurred())

})

type PolicyRuleMatcher struct {
	expRule cache.PolicyRule
}

func (matcher *PolicyRuleMatcher) Match(actual interface{}) (success bool, err error) {
	rule, ok := actual.(cache.PolicyRule)
	if !ok {
		return false, fmt.Errorf("PolicyRuleMatcher matcher requires PolicyRule.  Got:\n%s", actual)
	}
	expRule := matcher.expRule
	if expRule.Tier == rule.Tier &&
		expRule.Direction == rule.Direction &&
		expRule.Action == rule.Action &&
		expRule.SrcIPAddr == rule.SrcIPAddr &&
		expRule.DstIPAddr == rule.DstIPAddr &&
		expRule.DstPort == rule.DstPort &&
		expRule.DstPortMask == rule.DstPortMask &&
		expRule.IPProtocol == rule.IPProtocol &&
		expRule.IPFamily == rule.IPFamily &&
		expRule.PriorityOffset == rule.PriorityOffset &&
		expRule.SrcVNicRef == rule.SrcVNicRef &&
		expRule.DstVNicRef == rule.DstVNicRef {
		return true, nil
	}
	return false, nil
}

func (matcher *PolicyRuleMatcher) FailureMessage(actual interface{}) (message string) {
	return format.Message(actual, "match policyrule", matcher.expRule)
}

func (matcher *PolicyRuleMatcher) NegatedFailureMessage(actual interface{}) (message string) {
	return format.Message(actual, "not match policyrule", matcher.expRule)
}

func NewPolicyRuleMatcher(rule cache.PolicyRule) gtypes.GomegaMatcher {
	return &PolicyRuleMatcher{
		expRule: rule,
	}
}
