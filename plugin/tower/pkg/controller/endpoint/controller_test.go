/*
Copyright 2021 The Lynx Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package endpoint_test

import (
	"context"
	"fmt"
	"reflect"
	"testing"

	. "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/rand"

	controller "github.com/smartxworks/lynx/plugin/tower/pkg/controller/endpoint"
	"github.com/smartxworks/lynx/plugin/tower/pkg/schema"
	. "github.com/smartxworks/lynx/plugin/tower/pkg/utils/testing"
)

var _ = Describe("EndpointController", func() {
	var ctx context.Context

	BeforeEach(func() {
		ctx = context.Background()
	})
	AfterEach(func() {
		server.TrackerFactory().ResetAll()
		err := crdClient.SecurityV1alpha1().Endpoints(namespace).DeleteCollection(ctx,
			metav1.DeleteOptions{},
			metav1.ListOptions{},
		)
		Expect(err).Should(Succeed())
	})

	Context("has some available labels", func() {
		var labelA, labelB, labelC *schema.Label

		BeforeEach(func() {
			labelA = NewRandomLabel()
			labelB = NewRandomLabel()
			labelC = NewRandomLabel()

			By(fmt.Sprintf("create labels: %+v, %+v, %+v", labelA, labelB, labelC))
			server.TrackerFactory().Label().CreateOrUpdate(labelA)
			server.TrackerFactory().Label().CreateOrUpdate(labelB)
			server.TrackerFactory().Label().CreateOrUpdate(labelC)
		})

		When("create vm with one vnic and without labels", func() {
			var vm *schema.VM
			var vnic *schema.VMNic

			BeforeEach(func() {
				vm = NewRandomVM()
				vnic = NewRandomVMNicAttachedTo(vm)

				By(fmt.Sprintf("create vm %+v with vnic %+v", vm, vnic))
				server.TrackerFactory().VM().CreateOrUpdate(vm)
			})
			It("should create endpoint", func() {
				assertEndpointsNum(ctx, 1)
				assertHasEndpoint(ctx, vnic.GetID(), nil, vnic.InterfaceID)
			})

			When("delete vm", func() {
				BeforeEach(func() {
					By("make sure endpoint has been generated by EndpointController")
					assertEndpointsNum(ctx, 1)

					By(fmt.Sprintf("delete vm %+v", vm))
					err := server.TrackerFactory().VM().Delete(vm.GetID())
					Expect(err).ShouldNot(HaveOccurred())
				})
				It("should delete endpoint", func() {
					assertEndpointsNum(ctx, 0)
				})
			})
		})

		When("create vm with multiple vnics and labels", func() {
			var vm *schema.VM
			var vnicA, vnicB *schema.VMNic

			BeforeEach(func() {
				vm = NewRandomVM()
				vnicA = NewRandomVMNicAttachedTo(vm)
				vnicB = NewRandomVMNicAttachedTo(vm)

				labelA.VMs = append(labelA.VMs, schema.ObjectReference{ID: vm.GetID()})
				labelB.VMs = append(labelA.VMs, schema.ObjectReference{ID: vm.GetID()})

				By(fmt.Sprintf("create vm %+v and update label %+v and %+v", vm, labelA, labelB))
				server.TrackerFactory().VM().CreateOrUpdate(vm)
				server.TrackerFactory().Label().CreateOrUpdate(labelA)
				server.TrackerFactory().Label().CreateOrUpdate(labelB)

				By("wait for two endpoints create")
				assertEndpointsNum(ctx, 2)
			})
			It("should create endpoints", func() {
				assertEndpointsNum(ctx, 2)
				assertHasEndpoint(ctx, vnicA.GetID(), AggregateLabels(labelA, labelB), vnicA.InterfaceID)
				assertHasEndpoint(ctx, vnicB.GetID(), AggregateLabels(labelA, labelB), vnicB.InterfaceID)
			})

			When("add vnic to vm", func() {
				var newVNic *schema.VMNic

				BeforeEach(func() {
					newVNic = NewRandomVMNicAttachedTo(vm)
					By(fmt.Sprintf("update vm %+v with new vnic %+v", vm, newVNic))
					server.TrackerFactory().VM().CreateOrUpdate(vm)
				})
				It("should create endpoints", func() {
					assertEndpointsNum(ctx, 3)
					assertHasEndpoint(ctx, newVNic.GetID(), AggregateLabels(labelA, labelB), newVNic.InterfaceID)
				})
			})

			When("delete vnic from vm", func() {
				BeforeEach(func() {
					vm.VMNics = []schema.VMNic{*vnicA}
					By(fmt.Sprintf("update vm %+v remove vnic %+v", vm, vnicB))
					server.TrackerFactory().VM().CreateOrUpdate(vm)
				})
				It("should remove endpoint", func() {
					assertEndpointsNum(ctx, 1)
					assertHasEndpoint(ctx, vnicA.GetID(), AggregateLabels(labelA, labelB), vnicA.InterfaceID)
					assertNoEnpoint(ctx, vnicB.GetID())
				})
			})

			When("add label to vm", func() {
				BeforeEach(func() {
					labelC.VMs = append(labelC.VMs, schema.ObjectReference{ID: vm.ID})
					By(fmt.Sprintf("add new label %+v to vm %+v", labelC, vm))
					server.TrackerFactory().Label().CreateOrUpdate(labelC)
				})
				It("should update endpoint labels", func() {
					assertEndpointsNum(ctx, 2)
					assertHasEndpoint(ctx, vnicA.GetID(), AggregateLabels(labelA, labelB, labelC), vnicA.InterfaceID)
					assertHasEndpoint(ctx, vnicB.GetID(), AggregateLabels(labelA, labelB, labelC), vnicB.InterfaceID)
				})
			})

			When("delete label from vm", func() {
				BeforeEach(func() {
					labelB.VMs = nil
					By(fmt.Sprintf("remove label %+v from vm %+v", labelB, vm))
					server.TrackerFactory().Label().CreateOrUpdate(labelB)
				})
				It("should update endpoint labels", func() {
					assertEndpointsNum(ctx, 2)
					assertHasEndpoint(ctx, vnicA.GetID(), AggregateLabels(labelA), vnicA.InterfaceID)
					assertHasEndpoint(ctx, vnicB.GetID(), AggregateLabels(labelA), vnicB.InterfaceID)
				})
			})

			When("update vm attached label", func() {
				BeforeEach(func() {
					labelA.Value = rand.String(10)
					By(fmt.Sprintf("update labelA value to %s", labelA.Value))
					server.TrackerFactory().Label().CreateOrUpdate(labelA)
				})
				It("should update endpoint labels", func() {
					assertEndpointsNum(ctx, 2)
					assertHasEndpoint(ctx, vnicA.GetID(), AggregateLabels(labelA, labelB), vnicA.InterfaceID)
					assertHasEndpoint(ctx, vnicB.GetID(), AggregateLabels(labelA, labelB), vnicB.InterfaceID)
				})
			})

			When("delete vm", func() {
				BeforeEach(func() {
					By(fmt.Sprintf("delete vm %+v", vm))
					err := server.TrackerFactory().VM().Delete(vm.GetID())
					Expect(err).ShouldNot(HaveOccurred())
				})
				It("should delete endpoint", func() {
					assertEndpointsNum(ctx, 0)
				})
			})
		})

	})
})

func TestValidKubernetesLabel(t *testing.T) {
	testCases := []struct {
		labelKey    string
		labelValue  string
		expectValid bool
	}{
		{
			labelKey:    "中文标签",
			labelValue:  "value",
			expectValid: false,
		},
		{
			labelKey:    "key",
			labelValue:  "中文值",
			expectValid: false,
		},
		{
			labelKey:    "@invalid-char",
			labelValue:  "value",
			expectValid: false,
		},
		{
			labelKey:    "Key",
			labelValue:  "Value",
			expectValid: true,
		},
		{
			labelKey:    "key",
			labelValue:  "value",
			expectValid: true,
		},
	}

	for index, tc := range testCases {
		t.Run(fmt.Sprintf("case[%d]: key = %s, value = %s", index, tc.labelKey, tc.labelValue), func(t *testing.T) {
			isValidLabel := controller.ValidKubernetesLabel(&schema.Label{
				Key:   tc.labelKey,
				Value: tc.labelValue,
			})
			if tc.expectValid != isValidLabel {
				t.Fatalf("key = %s, value = %s, expect valid %t but not", tc.labelKey, tc.labelValue, tc.expectValid)
			}
		})
	}
}

func assertEndpointsNum(ctx context.Context, numOfEndpoints int) {
	Eventually(func() int {
		endpointList, err := crdClient.SecurityV1alpha1().Endpoints(namespace).List(ctx, metav1.ListOptions{})
		Expect(err).ShouldNot(HaveOccurred())
		return len(endpointList.Items)
	}, timeout, interval).Should(Equal(numOfEndpoints))
}

func assertHasEndpoint(ctx context.Context, epName string, labels map[string]string, externalIDValue string) {
	Eventually(func() bool {
		endpointList, err := crdClient.SecurityV1alpha1().Endpoints(namespace).List(ctx, metav1.ListOptions{})
		Expect(err).ShouldNot(HaveOccurred())

		for _, endpoint := range endpointList.Items {
			if endpoint.GetName() == epName &&
				reflect.DeepEqual(endpoint.GetLabels(), labels) &&
				endpoint.Spec.Reference.ExternalIDName == controller.ExternalIDName &&
				endpoint.Spec.Reference.ExternalIDValue == externalIDValue {
				return true
			}
		}
		return false
	}, timeout, interval).Should(BeTrue())
}

func assertNoEnpoint(ctx context.Context, epName string) {
	Eventually(func() bool {
		endpointList, err := crdClient.SecurityV1alpha1().Endpoints(namespace).List(ctx, metav1.ListOptions{})
		Expect(err).ShouldNot(HaveOccurred())

		for _, endpoint := range endpointList.Items {
			if endpoint.GetName() == epName {
				return true
			}
		}
		return false
	}, timeout, interval).Should(BeFalse())
}
