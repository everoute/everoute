/*
Copyright 2021 The Everoute Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package endpoint_test

import (
	"context"
	"fmt"
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	. "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/rand"
	"k8s.io/apimachinery/pkg/util/validation"

	"github.com/everoute/everoute/pkg/apis/security/v1alpha1"
	controller "github.com/everoute/everoute/plugin/tower/pkg/controller/endpoint"
	"github.com/everoute/everoute/plugin/tower/pkg/schema"
	. "github.com/everoute/everoute/plugin/tower/pkg/utils/testing"
)

var _ = Describe("EndpointController", func() {
	var ctx context.Context

	BeforeEach(func() {
		ctx = context.Background()
	})
	AfterEach(func() {
		server.TrackerFactory().ResetAll()
		err := crdClient.SecurityV1alpha1().Endpoints(namespace).DeleteCollection(ctx,
			metav1.DeleteOptions{},
			metav1.ListOptions{},
		)
		Expect(err).Should(Succeed())
	})

	Context("has some available labels", func() {
		var labelA, labelB, labelC *schema.Label

		BeforeEach(func() {
			labelA = NewRandomLabel()
			labelB = NewRandomLabel()
			labelC = NewRandomLabel()

			By(fmt.Sprintf("create labels: %+v, %+v, %+v", labelA, labelB, labelC))
			server.TrackerFactory().Label().CreateOrUpdate(labelA)
			server.TrackerFactory().Label().CreateOrUpdate(labelB)
			server.TrackerFactory().Label().CreateOrUpdate(labelC)
		})

		When("create vm with one vnic and without labels", func() {
			var vm *schema.VM
			var vnic *schema.VMNic

			BeforeEach(func() {
				vm = NewRandomVM()
				vnic = NewRandomVMNicAttachedTo(vm)

				By(fmt.Sprintf("create vm %+v with vnic %+v", vm, vnic))
				server.TrackerFactory().VM().CreateOrUpdate(vm)
			})
			It("should create endpoint", func() {
				assertEndpointsNum(ctx, 1)
				assertHasEndpoint(ctx, matchDynamic(vnic.GetID(), vnic.InterfaceID, nil, nil))
			})

			When("delete vm", func() {
				BeforeEach(func() {
					By("make sure endpoint has been generated by EndpointController")
					assertEndpointsNum(ctx, 1)

					By(fmt.Sprintf("delete vm %+v", vm))
					err := server.TrackerFactory().VM().Delete(vm.GetID())
					Expect(err).ShouldNot(HaveOccurred())
				})
				It("should delete endpoint", func() {
					assertEndpointsNum(ctx, 0)
				})
			})
		})

		When("create vm with multiple vnics and labels", func() {
			var vm *schema.VM
			var vnicA, vnicB *schema.VMNic

			BeforeEach(func() {
				vm = NewRandomVM()
				vnicA = NewRandomVMNicAttachedTo(vm)
				vnicB = NewRandomVMNicAttachedTo(vm)

				labelA.VMs = append(labelA.VMs, schema.ObjectReference{ID: vm.GetID()})
				labelB.VMs = append(labelA.VMs, schema.ObjectReference{ID: vm.GetID()})

				By(fmt.Sprintf("create vm %+v and update label %+v and %+v", vm, labelA, labelB))
				server.TrackerFactory().VM().CreateOrUpdate(vm)
				server.TrackerFactory().Label().CreateOrUpdate(labelA)
				server.TrackerFactory().Label().CreateOrUpdate(labelB)

				By("wait for two endpoints create")
				assertEndpointsNum(ctx, 2)
			})
			It("should create endpoints", func() {
				assertEndpointsNum(ctx, 2)
				assertHasEndpoint(ctx, matchDynamic(vnicA.GetID(), vnicA.InterfaceID, AggregateLabels(labelA, labelB), nil))
				assertHasEndpoint(ctx, matchDynamic(vnicB.GetID(), vnicB.InterfaceID, AggregateLabels(labelA, labelB), nil))
			})

			When("add vnic to vm", func() {
				var newVNic *schema.VMNic

				BeforeEach(func() {
					newVNic = NewRandomVMNicAttachedTo(vm)
					By(fmt.Sprintf("update vm %+v with new vnic %+v", vm, newVNic))
					server.TrackerFactory().VM().CreateOrUpdate(vm)
				})
				It("should create endpoints", func() {
					assertEndpointsNum(ctx, 3)
					assertHasEndpoint(ctx, matchDynamic(newVNic.GetID(), newVNic.InterfaceID, AggregateLabels(labelA, labelB), nil))
				})
			})

			When("delete vnic from vm", func() {
				BeforeEach(func() {
					vm.VMNics = []schema.VMNic{*vnicA}
					By(fmt.Sprintf("update vm %+v remove vnic %+v", vm, vnicB))
					server.TrackerFactory().VM().CreateOrUpdate(vm)
				})
				It("should remove endpoint", func() {
					assertEndpointsNum(ctx, 1)
					assertHasEndpoint(ctx, matchDynamic(vnicA.GetID(), vnicA.InterfaceID, AggregateLabels(labelA, labelB), nil))
					assertNoEnpoint(ctx, vnicB.GetID())
				})
			})

			When("add label to vm", func() {
				BeforeEach(func() {
					labelC.VMs = append(labelC.VMs, schema.ObjectReference{ID: vm.ID})
					By(fmt.Sprintf("add new label %+v to vm %+v", labelC, vm))
					server.TrackerFactory().Label().CreateOrUpdate(labelC)
				})
				It("should update endpoint labels", func() {
					assertEndpointsNum(ctx, 2)
					assertHasEndpoint(ctx, matchDynamic(vnicA.GetID(), vnicA.InterfaceID, AggregateLabels(labelA, labelB, labelC), nil))
					assertHasEndpoint(ctx, matchDynamic(vnicB.GetID(), vnicB.InterfaceID, AggregateLabels(labelA, labelB, labelC), nil))
				})
			})

			When("delete label from vm", func() {
				BeforeEach(func() {
					labelB.VMs = nil
					By(fmt.Sprintf("remove label %+v from vm %+v", labelB, vm))
					server.TrackerFactory().Label().CreateOrUpdate(labelB)
				})
				It("should update endpoint labels", func() {
					assertEndpointsNum(ctx, 2)
					assertHasEndpoint(ctx, matchDynamic(vnicA.GetID(), vnicA.InterfaceID, AggregateLabels(labelA), nil))
					assertHasEndpoint(ctx, matchDynamic(vnicB.GetID(), vnicB.InterfaceID, AggregateLabels(labelA), nil))
				})
			})

			When("update vm attached label", func() {
				BeforeEach(func() {
					labelA.Value = rand.String(10)
					By(fmt.Sprintf("update labelA value to %s", labelA.Value))
					server.TrackerFactory().Label().CreateOrUpdate(labelA)
				})
				It("should update endpoint labels", func() {
					assertEndpointsNum(ctx, 2)
					assertHasEndpoint(ctx, matchDynamic(vnicA.GetID(), vnicA.InterfaceID, AggregateLabels(labelA, labelB), nil))
					assertHasEndpoint(ctx, matchDynamic(vnicB.GetID(), vnicB.InterfaceID, AggregateLabels(labelA, labelB), nil))
				})
			})

			When("delete vm", func() {
				BeforeEach(func() {
					By(fmt.Sprintf("delete vm %+v", vm))
					err := server.TrackerFactory().VM().Delete(vm.GetID())
					Expect(err).ShouldNot(HaveOccurred())
				})
				It("should delete endpoint", func() {
					assertEndpointsNum(ctx, 0)
				})
			})
		})

	})

	Context("has some invalid kubernetes labels", func() {
		var labelA, labelB, labelC, labelD *schema.Label

		BeforeEach(func() {
			labelA = NewRandomLabel()
			labelB = NewLabel("@ä¸­æ–‡æ ‡ç­¾", "@invalid-char")
			labelC = NewLabel("@ä¸­æ–‡æ ‡ç­¾", "ä¸­æ–‡=>æ ‡ç­¾å€¼ï¼Ÿ")
			labelD = NewLabel("&^$*!@#3", "ä¸­æ–‡=>æ ‡ç­¾å€¼ï¼Ÿ")

			By(fmt.Sprintf("create labels: %+v, %+v, %+v, %+v", labelA, labelB, labelC, labelD))
			server.TrackerFactory().Label().CreateOrUpdate(labelA)
			server.TrackerFactory().Label().CreateOrUpdate(labelB)
			server.TrackerFactory().Label().CreateOrUpdate(labelC)
			server.TrackerFactory().Label().CreateOrUpdate(labelD)
		})

		When("create vm with multiple vnics and labels", func() {
			var vm *schema.VM
			var vnicA, vnicB *schema.VMNic

			BeforeEach(func() {
				vm = NewRandomVM()
				vnicA = NewRandomVMNicAttachedTo(vm)
				vnicB = NewRandomVMNicAttachedTo(vm)

				labelA.VMs = append(labelA.VMs, schema.ObjectReference{ID: vm.GetID()})
				labelB.VMs = append(labelA.VMs, schema.ObjectReference{ID: vm.GetID()})
				labelC.VMs = append(labelC.VMs, schema.ObjectReference{ID: vm.GetID()})
				labelD.VMs = append(labelD.VMs, schema.ObjectReference{ID: vm.GetID()})

				By(fmt.Sprintf("create vm %+v and update labels: %+v, %+v, %+v, %+v", vm, labelA, labelB, labelC, labelD))
				server.TrackerFactory().VM().CreateOrUpdate(vm)
				server.TrackerFactory().Label().CreateOrUpdate(labelA)
				server.TrackerFactory().Label().CreateOrUpdate(labelB)
				server.TrackerFactory().Label().CreateOrUpdate(labelC)
				server.TrackerFactory().Label().CreateOrUpdate(labelD)
			})
			It("should create endpoints", func() {
				assertEndpointsNum(ctx, 2)
				expectExtendLabels := map[string][]string{labelB.Key: {labelB.Value, labelC.Value}, labelD.Key: {labelD.Value}}
				assertHasEndpoint(ctx, matchDynamic(vnicA.GetID(), vnicA.InterfaceID, AggregateLabels(labelA), expectExtendLabels))
				assertHasEndpoint(ctx, matchDynamic(vnicB.GetID(), vnicB.InterfaceID, AggregateLabels(labelA), expectExtendLabels))
			})
		})
	})
})

var _ = Describe("SystemEndpointController", func() {
	var ctx context.Context

	BeforeEach(func() {
		ctx = context.Background()
	})
	AfterEach(func() {
		server.TrackerFactory().ResetAll()
		err := crdClient.SecurityV1alpha1().Endpoints(namespace).DeleteCollection(ctx,
			metav1.DeleteOptions{},
			metav1.ListOptions{},
		)
		Expect(err).Should(Succeed())
	})

	Context("generate endpoint", func() {
		When("create systemEndpoints", func() {
			var randomSystemEndpoints *schema.SystemEndpoints

			BeforeEach(func() {
				randomSystemEndpoints = NewSystemEndpoints(2)
				By(fmt.Sprintf("create random systemEndpoints %+v", randomSystemEndpoints))
				server.TrackerFactory().SystemEndpoints().CreateOrUpdate(randomSystemEndpoints)
			})
			It("should create endpoints", func() {
				assertEndpointsNum(ctx, 2)
				assertHasEndpoint(ctx, matchStatic(randomSystemEndpoints.IPPortEndpoints[0].IP))
				assertHasEndpoint(ctx, matchStatic(randomSystemEndpoints.IPPortEndpoints[1].IP))
			})

			When("update systemEndpoints", func() {
				BeforeEach(func() {
					randomSystemEndpoints.IPPortEndpoints[0] = schema.IPPortSystemEndpoint{IP: NewRandomIP().String()}
					By(fmt.Sprintf("update systemEndpoints to %+v", randomSystemEndpoints))
					server.TrackerFactory().SystemEndpoints().CreateOrUpdate(randomSystemEndpoints)
				})
				It("should update related endpoints", func() {
					assertEndpointsNum(ctx, 2)
					assertHasEndpoint(ctx, matchStatic(randomSystemEndpoints.IPPortEndpoints[0].IP))
					assertHasEndpoint(ctx, matchStatic(randomSystemEndpoints.IPPortEndpoints[1].IP))
				})
			})

			When("remove all endpoint for the systemEndpoints", func() {
				BeforeEach(func() {
					randomSystemEndpoints.IPPortEndpoints = nil
					By(fmt.Sprintf("remove all endpoint from systemEndpoints: %+v", randomSystemEndpoints))
					server.TrackerFactory().SystemEndpoints().CreateOrUpdate(randomSystemEndpoints)
				})
				It("should delete endpoints", func() {
					assertEndpointsNum(ctx, 0)
				})
			})
		})
		When("create EverouteCluster", func() {
			var cluster *schema.EverouteCluster

			BeforeEach(func() {
				cluster = NewEverouteCluster(everouteCluster, schema.GlobalPolicyActionAllow)
				By(fmt.Sprintf("create random everouteCluster %+v", everouteCluster))
				server.TrackerFactory().EverouteCluster().CreateOrUpdate(cluster)
			})
			It("should create endpoints", func() {
				assertEndpointsNum(ctx, 3)
				assertHasEndpoint(ctx, matchStatic(cluster.ControllerInstances[0].IPAddr))
				assertHasEndpoint(ctx, matchStatic(cluster.ControllerInstances[1].IPAddr))
				assertHasEndpoint(ctx, matchStatic(cluster.ControllerInstances[2].IPAddr))
			})

			When("update everouteCluster", func() {
				BeforeEach(func() {
					cluster.ControllerInstances[0].IPAddr = NewRandomIP().String()
					By(fmt.Sprintf("update everouteCluster to %+v", cluster))
					server.TrackerFactory().EverouteCluster().CreateOrUpdate(cluster)
				})
				It("should update related endpoints", func() {
					assertEndpointsNum(ctx, 3)
					assertHasEndpoint(ctx, matchStatic(cluster.ControllerInstances[0].IPAddr))
					assertHasEndpoint(ctx, matchStatic(cluster.ControllerInstances[1].IPAddr))
					assertHasEndpoint(ctx, matchStatic(cluster.ControllerInstances[2].IPAddr))
				})
			})

			When("remove all endpoint from everouteCluster", func() {
				BeforeEach(func() {
					cluster.ControllerInstances = nil
					By(fmt.Sprintf("remove all endpoint from everouteCluster: %+v", cluster))
					server.TrackerFactory().EverouteCluster().CreateOrUpdate(cluster)
				})
				It("should delete endpoints", func() {
					assertEndpointsNum(ctx, 0)
				})
			})
		})
	})

})

func TestValidKubernetesLabel(t *testing.T) {
	testCases := []struct {
		labelKey    string
		labelValue  string
		expectValid bool
	}{
		{
			labelKey:    "ä¸­æ–‡æ ‡ç­¾",
			labelValue:  "value",
			expectValid: false,
		},
		{
			labelKey:    "key",
			labelValue:  "ä¸­æ–‡å€¼",
			expectValid: false,
		},
		{
			labelKey:    "@invalid-char",
			labelValue:  "value",
			expectValid: false,
		},
		{
			labelKey:    "Key",
			labelValue:  "Value",
			expectValid: true,
		},
		{
			labelKey:    "key",
			labelValue:  "value",
			expectValid: true,
		},
	}

	for index, tc := range testCases {
		t.Run(fmt.Sprintf("case[%d]: key = %s, value = %s", index, tc.labelKey, tc.labelValue), func(t *testing.T) {
			isValidLabel := controller.ValidKubernetesLabel(&schema.Label{
				Key:   tc.labelKey,
				Value: tc.labelValue,
			})
			if tc.expectValid != isValidLabel {
				t.Fatalf("key = %s, value = %s, expect valid %t but not", tc.labelKey, tc.labelValue, tc.expectValid)
			}
		})
	}
}

func TestGetSystemEndpointName(t *testing.T) {
	testKeys := []string{
		"backup.cl77b1h8600uf2oud2d2cf5mq.storage",
		"cloudtower",
		"backup/cl77b1h8600uf2oud2d2cf5mq/storage",
		"string@with&special%&^characTer",
		"ä¸­æ–‡å­—ç¬¦ä¸²ðŸ’–",
		"key with space",
		"long_key_" + rand.String(1000),
	}

	for index, tk := range testKeys {
		t.Run(fmt.Sprintf("case[%d]: key = %s", index, tk), func(t *testing.T) {
			RegisterTestingT(t)
			key := controller.GetSystemEndpointName(tk)
			Expect(validation.IsDNS1123Subdomain(key)).Should(HaveLen(0))
		})
	}
}

func assertEndpointsNum(ctx context.Context, numOfEndpoints int) {
	Eventually(func() int {
		endpointList, err := crdClient.SecurityV1alpha1().Endpoints(namespace).List(ctx, metav1.ListOptions{})
		Expect(err).ShouldNot(HaveOccurred())
		return len(endpointList.Items)
	}, timeout, interval).Should(Equal(numOfEndpoints))
}

type matchEndpointFunc func(endpoint *v1alpha1.Endpoint) bool

func assertHasEndpoint(ctx context.Context, matchFunc matchEndpointFunc) {
	Eventually(func() bool {
		endpointList, err := crdClient.SecurityV1alpha1().Endpoints(namespace).List(ctx, metav1.ListOptions{})
		Expect(err).ShouldNot(HaveOccurred())

		for _, endpoint := range endpointList.Items {
			if matchFunc(&endpoint) {
				return true
			}
		}
		return false
	}, timeout, interval).Should(BeTrue())
}

func matchStatic(ip string) matchEndpointFunc {
	return func(endpoint *v1alpha1.Endpoint) bool {
		return len(endpoint.Status.IPs) == 1 &&
			endpoint.Status.IPs[0].String() == ip &&
			endpoint.Spec.Type == v1alpha1.EndpointStatic
	}
}

func matchDynamic(epName, externalIDValue string, labels map[string]string, extendLabels map[string][]string) matchEndpointFunc {
	lessFunc := func(x, y string) bool { return x < y }
	return func(endpoint *v1alpha1.Endpoint) bool {
		return endpoint.GetName() == epName &&
			cmp.Equal(endpoint.GetLabels(), labels, cmpopts.EquateEmpty()) &&
			cmp.Equal(endpoint.Spec.ExtendLabels, extendLabels, cmpopts.EquateEmpty(), cmpopts.SortSlices(lessFunc)) &&
			endpoint.Spec.Reference.ExternalIDName == controller.ExternalIDName &&
			endpoint.Spec.Reference.ExternalIDValue == externalIDValue &&
			endpoint.Spec.Type == v1alpha1.EndpointDynamic
	}
}

func assertNoEnpoint(ctx context.Context, epName string) {
	Eventually(func() bool {
		endpointList, err := crdClient.SecurityV1alpha1().Endpoints(namespace).List(ctx, metav1.ListOptions{})
		Expect(err).ShouldNot(HaveOccurred())

		for _, endpoint := range endpointList.Items {
			if endpoint.GetName() == epName {
				return true
			}
		}
		return false
	}, timeout, interval).Should(BeFalse())
}
