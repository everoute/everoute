#!/usr/bin/env bash

set -v

function error_handle {
    sleep 1
    exit 1
}

# init cni
echo "init cni"
mkdir -p /var/run/everoute
chmod 755 /var/run/everoute

install -m 755 /opt/everoute/bin/everoute-cni /opt/cni/bin/everoute
install -m 755 /opt/everoute/bin/host-local /opt/cni/bin/host-local
install -m 755 /opt/everoute/bin/loopback /opt/cni/bin/loopback
install -m 755 /opt/everoute/bin/portmap /opt/cni/bin/portmap

rm -f /var/lib/everoute/agent/name
rm -f /etc/cni/net.d/10-everoute.conf
rm -f /etc/cni/net.d/10-everoute.conflist
install -m 644 /var/lib/everoute/cni-conf.conflist /etc/cni/net.d/10-everoute.conflist

# init iptables drivers
modprobe iptable_nat
modprobe iptable_filter
modprobe iptable_raw
modprobe iptable_mangle

# init ovs
echo "init ovs"
modprobe openvswitch || depmod -a || modprobe openvswitch || (echo "modprobe openvswitch error"; exit 1)

source /usr/share/openvswitch/scripts/ovs-lib

OVS_DB_FILE="/var/run/everoute/openvswitch.db"

function start_ovs {
    if daemon_is_running ovsdb-server; then
        echo "ovsdb-server is already running"
    else
        echo "Starting ovsdb-server"
        /usr/share/openvswitch/scripts/ovs-ctl --no-ovs-vswitchd --system-id=random start --db-file=$OVS_DB_FILE
        echo "Started ovsdb-server"
    fi

    if daemon_is_running ovs-vswitchd; then
        echo "ovs-vswitchd is already running"
    else
        echo "Starting ovs-vswitchd"
        /usr/share/openvswitch/scripts/ovs-ctl --no-ovsdb-server --system-id=random start --db-file=$OVS_DB_FILE
        echo "Started ovs-vswitchd"
    fi
    ovs-appctl vlog/set info
}

start_ovs

# init bridge
echo "init bridge"
AGENT_CONFIG_PATH=/var/lib/everoute/agentconfig.yaml

EVEROUTE_ROUTE_TABLE=100
EVEROUTE_IP_RULE_PREF=100
LOCAL_IP_RULE_PREF=200

DEFAULT_BRIDGE=`cat ${AGENT_CONFIG_PATH} | grep datapathConfig: -A1 | grep -v datapathConfig: | awk -F ':' '{print $1}' | awk '$1=$1'`
LOCAL_GW_IP=`cat ${AGENT_CONFIG_PATH} | grep localGwIP | awk -F ':' '{print $2}' | awk '$1=$1'`
GW_IFACE=${DEFAULT_BRIDGE}-gw
GW_LOCAL_IFACE=${DEFAULT_BRIDGE}-gw-local
POLICY_BRIDGE="${DEFAULT_BRIDGE}-policy"
CLS_BRIDGE="${DEFAULT_BRIDGE}-cls"
UPLINK_BRIDGE="${DEFAULT_BRIDGE}-uplink"
NAT_BRIDGE="${DEFAULT_BRIDGE}-nat"

LOCAL_TO_POLICY_PATCH="${DEFAULT_BRIDGE}-local-to-policy"
POLICY_TO_LOCAL_PATCH="${POLICY_BRIDGE}-policy-to-local"
POLICY_TO_CLS_PATCH="${POLICY_BRIDGE}-policy-to-cls"
CLS_TO_POLICY_PATCH="${CLS_BRIDGE}-cls-to-policy"
CLS_TO_UPLINK_PATCH="${CLS_BRIDGE}-cls-to-uplink"
UPLINK_TO_CLS_PATCH="${UPLINK_BRIDGE}-uplink-to-cls"
LOCAL_TO_NAT_PATCH="${DEFAULT_BRIDGE}-local-to-nat"
NAT_TO_LOCAL_PATCH="${DEFAULT_BRIDGE}-nat-to-local"

ovs-vsctl add-br ${DEFAULT_BRIDGE} -- set bridge ${DEFAULT_BRIDGE} protocols=OpenFlow10,OpenFlow11,OpenFlow12,OpenFlow13 fail_mode=secure
ovs-vsctl add-br ${POLICY_BRIDGE} -- set bridge ${POLICY_BRIDGE} protocols=OpenFlow10,OpenFlow11,OpenFlow12,OpenFlow13 fail_mode=secure
ovs-vsctl add-br ${CLS_BRIDGE} -- set bridge ${CLS_BRIDGE} protocols=OpenFlow10,OpenFlow11,OpenFlow12,OpenFlow13 fail_mode=secure
ovs-vsctl add-br ${UPLINK_BRIDGE} -- set bridge ${UPLINK_BRIDGE} protocols=OpenFlow10,OpenFlow11,OpenFlow12,OpenFlow13 fail_mode=secure
ovs-vsctl add-br ${NAT_BRIDGE} -- set bridge ${NAT_BRIDGE} protocols=OpenFlow10,OpenFlow11,OpenFlow12,OpenFlow13 fail_mode=secure

ip link set ${DEFAULT_BRIDGE} up
ip link set ${POLICY_BRIDGE} up
ip link set ${CLS_BRIDGE} up
ip link set ${UPLINK_BRIDGE} up
ip link set ${NAT_BRIDGE} up

ovs-vsctl \
    -- add-port ${DEFAULT_BRIDGE} ${LOCAL_TO_POLICY_PATCH} \
    -- set interface ${LOCAL_TO_POLICY_PATCH} type=patch options:peer=${POLICY_TO_LOCAL_PATCH} \
    -- add-port ${POLICY_BRIDGE} ${POLICY_TO_LOCAL_PATCH} \
    -- set interface ${POLICY_TO_LOCAL_PATCH} type=patch options:peer=${LOCAL_TO_POLICY_PATCH}

ovs-vsctl \
    -- add-port ${DEFAULT_BRIDGE} ${LOCAL_TO_NAT_PATCH} \
    -- set interface ${LOCAL_TO_NAT_PATCH} type=patch options:peer=${NAT_TO_LOCAL_PATCH} \
    -- add-port ${NAT_BRIDGE} ${NAT_TO_LOCAL_PATCH} \
    -- set interface ${NAT_TO_LOCAL_PATCH} type=patch options:peer=${LOCAL_TO_NAT_PATCH}

ovs-vsctl \
    -- add-port ${POLICY_BRIDGE} ${POLICY_TO_CLS_PATCH} \
    -- set interface ${POLICY_TO_CLS_PATCH} type=patch options:peer=${CLS_TO_POLICY_PATCH} \
    -- add-port ${CLS_BRIDGE} ${CLS_TO_POLICY_PATCH} \
    -- set interface ${CLS_TO_POLICY_PATCH} type=patch options:peer=${POLICY_TO_CLS_PATCH}

ovs-vsctl \
    -- add-port ${UPLINK_BRIDGE} ${UPLINK_TO_CLS_PATCH} \
    -- set interface ${UPLINK_TO_CLS_PATCH} type=patch options:peer=${CLS_TO_UPLINK_PATCH} \
    -- add-port ${CLS_BRIDGE} ${CLS_TO_UPLINK_PATCH} \
    -- set interface ${CLS_TO_UPLINK_PATCH} type=patch options:peer=${UPLINK_TO_CLS_PATCH}

ovs-vsctl add-port ${UPLINK_BRIDGE} ${GW_IFACE} -- set Interface ${GW_IFACE} type=internal

# add port gw-local
ovs-vsctl add-port ${DEFAULT_BRIDGE} ${GW_LOCAL_IFACE} -- set Interface ${GW_LOCAL_IFACE} type=internal
ip link set ${GW_LOCAL_IFACE} up
ip addr add ${LOCAL_GW_IP}/32 dev ${GW_LOCAL_IFACE}

# add policy route
ip rule add preference ${LOCAL_IP_RULE_PREF} lookup local
ip rule add preference ${EVEROUTE_IP_RULE_PREF} iif ${GW_LOCAL_IFACE} table ${EVEROUTE_ROUTE_TABLE}
ip rule delete preference 0
ip route add default via ${LOCAL_GW_IP} dev ${GW_LOCAL_IFACE} table ${EVEROUTE_ROUTE_TABLE}

# set sysctl
echo 0 > /proc/sys/net/ipv4/conf/all/rp_filter
echo 0 > /proc/sys/net/ipv4/conf/${GW_IFACE}/rp_filter
echo 0 > /proc/sys/net/ipv4/conf/${GW_LOCAL_IFACE}/rp_filter
echo 2 > /proc/sys/net/ipv4/conf/${GW_LOCAL_IFACE}/arp_announce
echo 0 > /proc/sys/net/ipv4/ip_early_demux

# check configuration
## check ip link exist
echo "check ip link exist"
ip link show ${DEFAULT_BRIDGE} || error_handle
ip link show ${POLICY_BRIDGE} || error_handle
ip link show ${CLS_BRIDGE} || error_handle
ip link show ${UPLINK_BRIDGE} || error_handle
ip link show ${GW_IFACE} || error_handle
ip link show ${GW_LOCAL_IFACE} || error_handle
## check ip address exist
echo "check ip address exist"
ip addr add ${LOCAL_GW_IP}/32 dev ${GW_LOCAL_IFACE} && error_handle
ip addr add ${LOCAL_GW_IP}/32 dev ${GW_LOCAL_IFACE} || [[ $? -ne 2 ]] && error_handle
## check policy rule
echo "check policy rule"
[[ `ip rule list preference ${LOCAL_IP_RULE_PREF} lookup local | wc -l` -eq 0 ]] && error_handle
[[ `ip rule list preference ${EVEROUTE_IP_RULE_PREF} iif ${GW_LOCAL_IFACE} table ${EVEROUTE_ROUTE_TABLE} | wc -l` -eq 0 ]] && error_handle
[[ `ip rule list preference 0 | wc -l` -ne 0 ]] && error_handle
ip route add default via ${LOCAL_GW_IP} dev ${GW_LOCAL_IFACE} table ${EVEROUTE_ROUTE_TABLE} && error_handle
ip route add default via ${LOCAL_GW_IP} dev ${GW_LOCAL_IFACE} table ${EVEROUTE_ROUTE_TABLE} || [[ $? -ne 2 ]] && error_handle
## check sysctl
echo "check sysctl"
[[ `cat /proc/sys/net/ipv4/conf/all/rp_filter` -ne 0 ]] && error_handle
[[ `cat /proc/sys/net/ipv4/conf/${GW_IFACE}/rp_filter` -ne 0 ]] && error_handle
[[ `cat /proc/sys/net/ipv4/conf/${GW_LOCAL_IFACE}/rp_filter` -ne 0 ]] && error_handle
[[ `cat /proc/sys/net/ipv4/conf/${GW_LOCAL_IFACE}/arp_announce` -ne 2 ]] && error_handle
[[ `cat /proc/sys/net/ipv4/ip_early_demux` -ne 0 ]] && error_handle

echo "finish init"
touch /tmp/everoute_agent_init

function check_ovs_status {
    /usr/share/openvswitch/scripts/ovs-ctl status
    return $?
}
while true; do
    # we run sleep in the background so that we can immediately exit when we
    # receive SIGINT / SIGTERM
    # see https://stackoverflow.com/questions/32041674/linux-how-to-kill-sleep
    sleep 30 &
    wait $!

    if ! check_ovs_status > /dev/null ; then
        # OVS was stopped in the container.
        echo "OVS was stopped. Starting it again"
        start_ovs
    fi

done
